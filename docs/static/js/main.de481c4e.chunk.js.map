{"version":3,"sources":["services/getDataFromApi.js","images/logo.png","components/Header.js","components/Filters.js","components/CharacterCard.js","images/no_results2.png","components/CharacterList.js","components/CharacterDetail.js","images/404error.jpeg","components/App.js","index.js"],"names":["getDataFromApi","fetch","then","response","json","data","results","map","character","console","log","id","image","name","species","origin","episode","status","type","Header","className","src","logo","alt","Filters","props","onSubmit","ev","preventDefault","htmlFor","value","nameFilter","onChange","handleFilter","target","CharacterCard","to","CharacterList","characterElements","characters","length","title","CharacterDetail","checkStatus","App","useState","setCharacters","setNameFilter","useEffect","filteredCharacters","filter","toLowerCase","includes","exact","path","render","userId","parseInt","match","params","characterId","clickedCharacter","find","notFound","ReactDOM","document","getElementById"],"mappings":"qSAuBeA,G,MAvBQ,WAErB,OAAOC,MAAM,8CACVC,MAAK,SAACC,GAAD,OAAcA,EAASC,UAC5BF,MAAK,SAACG,GAEL,OAAOA,EAAKC,QAAQC,KAAI,SAACC,GAGvB,OAFAC,QAAQC,IAAIF,GAEL,CACLG,GAAIH,EAAUG,GACdC,MAAOJ,EAAUI,MACjBC,KAAML,EAAUK,KAChBC,QAASN,EAAUM,QACnBC,OAAQP,EAAUO,OAAOF,KACzBG,QAASR,EAAUQ,QACnBC,OAAQT,EAAUS,OAClBC,KAAMV,EAAUU,cCjBX,MAA0B,iC,OCY1BC,EARA,WACb,OACE,wBAAQC,UAAU,SAAlB,SACE,qBAAKA,UAAU,OAAOC,IAAKC,EAAMC,IAAI,2BCsB5BC,EA1BC,SAACC,GAUf,OACE,uBAAMC,SALiB,SAACC,GACxBA,EAAGC,kBAIH,UACE,uBAAOR,UAAU,QAAQS,QAAQ,OAAjC,iCAGA,uBACET,UAAU,QACVF,KAAK,OACLP,GAAG,OACHmB,MAAOL,EAAMM,WACbC,SAlBe,SAACL,GACpBF,EAAMQ,aAAaN,EAAGO,OAAOJ,cCwBlBK,G,MAxBO,SAACV,GAErB,OACE,oBAAIL,UAAU,OAAd,SACE,eAAC,IAAD,CAAMgB,GAAE,4BAAuBX,EAAMjB,UAAUG,IAA/C,UACE,qBACES,UAAU,YACVC,IAAKI,EAAMjB,UAAUI,MACrBW,IAAG,oBAAeE,EAAMjB,UAAUK,QAEpC,oBAAIO,UAAU,cAAd,SAA6BK,EAAMjB,UAAUK,OAC7C,mBAAGO,UAAU,oBAAb,SAAkCK,EAAMjB,UAAUM,iBCjB3C,G,MAAA,IAA0B,yCCmD1BuB,EA7CO,SAACZ,GAGrB,IAAMa,EAAoBb,EAAMc,WAAWhC,KAAI,SAACC,GAC9C,OACE,cAAC,EAAD,CAEEA,UAAWA,EACXK,KAAML,EAAUK,KAChBC,QAASN,EAAUM,QACnBF,MAAOJ,EAAUI,OAJZJ,EAAUG,OAUrB,OAAgC,IAA5Bc,EAAMc,WAAWC,OAEjB,gCACE,mBAAGpB,UAAU,aAAb,yCACA,qBACEA,UAAU,kBACVC,IAAKT,EACLW,IAAI,oBACJkB,MAAM,yBAOZ,qBAAKrB,UAAU,iBAAf,SACE,oBAAIA,UAAU,YAAd,SAA2BkB,OCkBlBI,G,MAjDS,SAACjB,GASvB,OACE,sBAAKL,UAAU,SAAf,UACE,qBAAKA,UAAU,uBAAf,SACE,cAAC,IAAD,CAAMgB,GAAG,IAAT,SACE,wBAAQhB,UAAU,cAAlB,wBAGJ,sBAAKA,UAAU,uBAAf,UACE,qBACEA,UAAU,4BACVC,IAAKI,EAAMb,MACXW,IAAKE,EAAMZ,KACX4B,MAAK,oBAAehB,EAAMZ,QAE5B,sBAAKO,UAAU,eAAf,UACE,oBAAIA,UAAU,eAAd,SAA8BK,EAAMZ,OACpC,qBAAIO,UAAU,sBAAd,UACE,2CAAcK,EAAMX,QAApB,OACA,qDAAwBW,EAAMV,OAA9B,OACA,8CAAiBU,EAAMT,QAAvB,iBACA,2CACYS,EAAMR,OADlB,KA1BU,WAClB,GAAqB,SAAjBQ,EAAMR,OACR,MAAO,eAyB2B0B,iBApBPlB,EAAMd,MCjBxB,MAA0B,sCCqF1BiC,EA1EH,WAEV,MAAoCC,mBAAS,IAA7C,mBAAON,EAAP,KAAmBO,EAAnB,KACA,EAAoCD,mBAAS,IAA7C,mBAAOd,EAAP,KAAmBgB,EAAnB,KAGAC,qBAAU,WAERhD,IAAiBE,MAAK,SAACG,GACrByC,EAAczC,QAEf,IAGH,IAKM4C,EAAqBV,EAAWW,QAAO,SAAC1C,GAC5C,OAAOA,EAAUK,KAAKsC,cAAcC,SAASrB,EAAWoB,kBAiC1D,OACE,sBAAK/B,UAAU,MAAf,UACE,cAAC,EAAD,IACA,eAAC,IAAD,WACE,eAAC,IAAD,CAAOiC,OAAK,EAACC,KAAK,IAAlB,UACE,cAAC,EAAD,CAASrB,aA5CI,SAACF,GACpBgB,EAAchB,IA2C6BA,WAAYA,IACjD,cAAC,EAAD,CAAeQ,WAAYU,OAE7B,cAAC,IAAD,CACEK,KAAK,iCACLC,OAvCsB,SAAC9B,GAC7B,IAAM+B,EAASC,SAAShC,EAAMiC,MAAMC,OAAOC,aACrCC,EAAmBtB,EAAWuB,MAAK,SAACtD,GACxC,OAAOA,EAAUG,KAAO6C,KAG1B,OAAIK,EAGA,cAAC,EAAD,CACEjD,MAAOiD,EAAiBjD,MACxBC,KAAMgD,EAAiBhD,KACvBI,OAAQ4C,EAAiB5C,OACzBH,QAAS+C,EAAiB/C,QAC1BC,OAAQ8C,EAAiB9C,OACzBC,QAAS6C,EAAiB7C,QAAQwB,SAMpC,sBAAKpB,UAAU,WAAf,UACE,mEACA,qBAAKA,UAAU,YAAYC,IAAK0C,EAAUxC,IAAI,2BCpDxDyC,IAAST,OACP,cAAC,IAAD,UACE,cAAC,EAAD,MAEFU,SAASC,eAAe,W","file":"static/js/main.de481c4e.chunk.js","sourcesContent":["const getDataFromApi = () => {\r\n  // hacemos la llamada al servidor y retornamos la promesa\r\n  return fetch(\"https://rickandmortyapi.com/api/character/\")\r\n    .then((response) => response.json())\r\n    .then((data) => {\r\n      // console.log(data.results);\r\n      return data.results.map((character) => {\r\n        console.log(character);\r\n        // los datos que quiero sacar de todos los que hay en la API son:\r\n        return {\r\n          id: character.id,\r\n          image: character.image,\r\n          name: character.name,\r\n          species: character.species,\r\n          origin: character.origin.name,\r\n          episode: character.episode,\r\n          status: character.status,\r\n          type: character.type,\r\n        };\r\n      });\r\n    });\r\n};\r\n\r\nexport default getDataFromApi;\r\n","export default __webpack_public_path__ + \"static/media/logo.de13d484.png\";","import React from 'react';\r\nimport logo from '../images/logo.png';\r\nimport '../stylesheet/App.scss';\r\n\r\nconst Header = () => {\r\n  return (\r\n    <header className=\"header\">\r\n      <img className=\"logo\" src={logo} alt=\"Rick and Morty logo\" />\r\n    </header>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import React from \"react\";\r\nimport \"../stylesheet/App.scss\";\r\n\r\nconst Filters = (props) => {\r\n  // evento que sube hasta App mediante lifting\r\n  const handleChange = (ev) => {\r\n    props.handleFilter(ev.target.value);\r\n  };\r\n  // Si, estando en el campo de filtrado pulsamos intro, debo impedir que el navegador navegue o cambie la ruta sin querer.\r\n  const handleFormSubmit = (ev) => {\r\n    ev.preventDefault();\r\n  };\r\n  // Pinto el campo de texto que busca el nombre del personaje. Como nos gusta cuidar la semántica, este debe estar recubierto por una etiqueta <form />.\r\n  return (\r\n    <form onSubmit={handleFormSubmit}>\r\n      <label className=\"label\" htmlFor=\"name\">\r\n        Busca un personaje:\r\n      </label>\r\n      <input\r\n        className=\"input\"\r\n        type=\"text\"\r\n        id=\"name\"\r\n        value={props.nameFilter}\r\n        onChange={handleChange}\r\n      />\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default Filters;\r\n","import React from \"react\";\nimport \"../stylesheet/CharacterCard.scss\";\nimport { Link } from \"react-router-dom\";\nimport PropTypes from \"prop-types\";\n\n// 1. LISTADO DE PERSONAJES. Pinto el contenido dentro de cada tarjeta de personaje: cada una es un <li> que contiene una imagen, nombre y especie del personaje en cuestión.\nconst CharacterCard = (props) => {\n  // console.log(props);\n  return (\n    <li className=\"card\">\n      <Link to={`/character-detail/${props.character.id}`}>\n        <img\n          className=\"card__img\"\n          src={props.character.image}\n          alt={`Imagen de ${props.character.name}`}\n        />\n        <h3 className=\"card__title\">{props.character.name}</h3>\n        <p className=\"card__description\">{props.character.species}</p>\n      </Link>\n    </li>\n  );\n};\n\nCharacterCard.propTypes = {\n  id: PropTypes.number,\n  image: PropTypes.string,\n  name: PropTypes.string,\n  specie: PropTypes.string,\n};\n\nexport default CharacterCard;\n","export default __webpack_public_path__ + \"static/media/no_results2.6ddd7d90.png\";","import React from \"react\";\nimport CharacterCard from \"./CharacterCard.js\";\nimport \"../stylesheet/CharacterList.scss\";\nimport image from \"../images/no_results2.png\";\nimport PropTypes from \"prop-types\";\n\nconst CharacterList = (props) => {\n  // console.log(props);\n  // Recibo por props los datos de App y pinto una lista que contendrá, mediante un mapeo, cada una de las tarjetas de los personajes como un item dentro de dicha lista.\n  const characterElements = props.characters.map((character) => {\n    return (\n      <CharacterCard\n        key={character.id}\n        character={character}\n        name={character.name}\n        species={character.species}\n        image={character.image}\n      />\n    );\n  });\n\n  // Si se busca un texto como XXX y no hay ningún personaje que coincida, se debe mostrar un mensaje del tipo \"No hay ningun personaje que coincida con la búsqueda\".\n  if (props.characters.length === 0) {\n    return (\n      <div>\n        <p className=\"no-results\">No se encuentran resultados</p>\n        <img\n          className=\"no-results__img\"\n          src={image}\n          alt=\"No hay resultados\"\n          title=\"No hay resultados\"\n        />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"list-container\">\n      <ul className=\"card-list\">{characterElements}</ul>\n    </div>\n  );\n};\n\nCharacterList.propTypes = {\n  character: PropTypes.array,\n  id: PropTypes.number,\n  name: PropTypes.string,\n  image: PropTypes.string,\n  species: PropTypes.string,\n};\n\nexport default CharacterList;\n","import React from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport \"../stylesheet/CharacterDetail.scss\";\r\nimport PropTypes from \"prop-types\";\r\n\r\n// 4. DETALLE DE PERSONAJES. Nueva funcionalidad: al hacer clic sobre la tarjeta de un personaje, su información aparecerá a pantalla completa. Usaremos rutas y React router. En la pantalla de detalle aparecerá además de la foto, nombre y especie, el planeta de origen, el número de episodios en los que aparece y si está vivo o muerto.\r\n\r\nconst CharacterDetail = (props) => {\r\n  // console.log(props);\r\n  // 6. BONUS: Mejoras visuales. Mostrar si un personaje está muerto con un icono.\r\n  const checkStatus = () => {\r\n    if (props.status === \"Dead\") {\r\n      return \"💀\";\r\n    }\r\n  };\r\n  // Renderizo en otra página la tarjeta de detalle de un personaje una vez la usaria la selecciona. Para ello he utilizado React Router.\r\n  return (\r\n    <div className=\"detail\" key={props.id}>\r\n      <div className=\"detail__btncontainer\">\r\n        <Link to=\"/\">\r\n          <button className=\"detail__btn\">Volver</button>\r\n        </Link>\r\n      </div>\r\n      <div className=\"detail__imgcontainer\">\r\n        <img\r\n          className=\"detail__imgcontainer--img\"\r\n          src={props.image}\r\n          alt={props.name}\r\n          title={`Imagen de ${props.name}`}\r\n        />\r\n        <div className=\"detail__text\">\r\n          <h2 className=\"detail__name\">{props.name}</h2>\r\n          <ul className=\"detail__description\">\r\n            <li>Especie: {props.species}.</li>\r\n            <li>Planeta de origen: {props.origin}.</li>\r\n            <li>Aparece en: {props.episode} episodios.</li>\r\n            <li>\r\n              Estatus: {props.status}. {checkStatus()}\r\n            </li>\r\n          </ul>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nCharacterDetail.propTypes = {\r\n  id: PropTypes.number,\r\n  name: PropTypes.string,\r\n  image: PropTypes.string,\r\n  species: PropTypes.string,\r\n  status: PropTypes.string,\r\n  origin: PropTypes.string,\r\n  episode: PropTypes.number,\r\n};\r\n\r\nexport default CharacterDetail;\r\n","export default __webpack_public_path__ + \"static/media/404error.d97eab6a.jpeg\";","import React, { useEffect, useState } from \"react\";\nimport { Route, Switch } from \"react-router-dom\";\nimport \"../stylesheet/App.scss\";\nimport getDataFromApi from \"../services/getDataFromApi\";\nimport Header from \"./Header\";\nimport Filters from \"./Filters\";\nimport CharacterList from \"./CharacterList\";\nimport CharacterDetail from \"./CharacterDetail\";\nimport notFound from \"../images/404error.jpeg\";\nimport PropTypes from \"prop-types\";\n\nconst App = () => {\n  // usamos el hook useState para definir dos propiedades del estado del componente (cada uno de esos hooks actúa sobre la propiedad especificada por medio de la función que le hemos pasado en cada caso, recibiendo como argumento inicial de useState un array y un string vacío.\n  const [characters, setCharacters] = useState([]);\n  const [nameFilter, setNameFilter] = useState(\"\");\n\n  // Recojo los datos del API haciendo uso del ciclo de vida de los componentes para evitar llamadas innecesarias a la misma.\n  useEffect(() => {\n    // llamo al servicio\n    getDataFromApi().then((data) => {\n      setCharacters(data); // cuando responde el servidor guardamos los datos en el estado\n    });\n  }, []); // con este array vacío, le decimos a React que solo ejecute este useEffect una vez\n\n  // Función manejadora del input que le paso por lifting a Filters.js para que la ejecute cuando sea necesario: \"Toma, hija, esta función, y ejecútamela cuando quieras\". Recibo por lifting el evento y la información que la usuaria escribe en el campo de texto, la cual es utilizada para filtrar los nombres de los personajes que coincidan con dicho texto.\n  const handleFilter = (nameFilter) => {\n    setNameFilter(nameFilter);\n  };\n\n  // Filtro personajes independientemente de que la usuaria introduzca el texto en mayúsculas o minúsculas.\n  const filteredCharacters = characters.filter((character) => {\n    return character.name.toLowerCase().includes(nameFilter.toLowerCase());\n  });\n\n  // Busco y pinto las tarjetas de los personajes que ha clicado la usuaria\n  const renderCharacterDetail = (props) => {\n    const userId = parseInt(props.match.params.characterId);\n    const clickedCharacter = characters.find((character) => {\n      return character.id === userId;\n    });\n\n    if (clickedCharacter) {\n      // console.log(clickedCharacter);\n      return (\n        <CharacterDetail\n          image={clickedCharacter.image}\n          name={clickedCharacter.name}\n          status={clickedCharacter.status}\n          species={clickedCharacter.species}\n          origin={clickedCharacter.origin}\n          episode={clickedCharacter.episode.length}\n        ></CharacterDetail>\n      );\n    } else {\n      // 7. BONUS: URL compatible. En el caso que la usuaria navegue a una URL inexistente, debemos mostrar un mensaje del tipo \"el personaje que buscas no existe\".\n      return (\n        <div className=\"notFound\">\n          <h2>El personaje que buscas no existe</h2>\n          <img className=\"not-found\" src={notFound} alt=\"not found\" />\n        </div>\n      );\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <Header />\n      <Switch>\n        <Route exact path=\"/\">\n          <Filters handleFilter={handleFilter} nameFilter={nameFilter} />\n          <CharacterList characters={filteredCharacters} />\n        </Route>\n        <Route\n          path=\"/character-detail/:characterId\"\n          render={renderCharacterDetail}\n        ></Route>\n      </Switch>\n    </div>\n  );\n};\n\nApp.propTypes = {\n  filteredCharacters: PropTypes.array,\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { HashRouter } from \"react-router-dom\";\nimport \"./stylesheet/index.scss\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <HashRouter>\n    <App />\n  </HashRouter>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}