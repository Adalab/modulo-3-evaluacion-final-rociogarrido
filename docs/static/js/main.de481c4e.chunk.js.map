{"version":3,"sources":["services/getDataFromApi.js","images/logo.png","components/Header.js","components/Filters.js","components/CharacterCard.js","images/no_results2.png","components/CharacterList.js","components/CharacterDetail.js","images/404error.jpeg","components/App.js","index.js"],"names":["getDataFromApi","fetch","then","response","json","data","results","map","character","console","log","id","image","name","species","origin","episode","status","type","Header","className","src","logo","alt","Filters","props","onSubmit","ev","preventDefault","htmlFor","value","nameFilter","onChange","handleFilter","target","CharacterCard","to","CharacterList","characterElements","characters","length","title","CharacterDetail","checkStatus","App","useState","setCharacters","setNameFilter","useEffect","filteredCharacters","filter","toLowerCase","includes","exact","path","render","userId","parseInt","match","params","characterId","clickedCharacter","find","notFound","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.de481c4e.chunk.js","sourcesContent":["const getDataFromApi = () => {\r\n  // hacemos la llamada al servidor y retornamos la promesa\r\n  return fetch(\"https://rickandmortyapi.com/api/character/\")\r\n    .then((response) => response.json())\r\n    .then((data) => {\r\n      // console.log(data.results);\r\n      return data.results.map((character) => {\r\n        console.log(character);\r\n        // los datos que quiero sacar de todos los que hay en la API son:\r\n        return {\r\n          id: character.id,\r\n          image: character.image,\r\n          name: character.name,\r\n          species: character.species,\r\n          origin: character.origin.name,\r\n          episode: character.episode,\r\n          status: character.status,\r\n          type: character.type,\r\n        };\r\n      });\r\n    });\r\n};\r\n\r\nexport default getDataFromApi;\r\n","export default __webpack_public_path__ + \"static/media/logo.de13d484.png\";","import React from 'react';\r\nimport logo from '../images/logo.png';\r\nimport '../stylesheet/App.scss';\r\n\r\nconst Header = () => {\r\n  return (\r\n    <header className=\"header\">\r\n      <img className=\"logo\" src={logo} alt=\"Rick and Morty logo\" />\r\n    </header>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import React from \"react\";\r\nimport \"../stylesheet/App.scss\";\r\n\r\nconst Filters = (props) => {\r\n  // evento que sube hasta App mediante lifting\r\n  const handleChange = (ev) => {\r\n    props.handleFilter(ev.target.value);\r\n  };\r\n  // Si, estando en el campo de filtrado pulsamos intro, debo impedir que el navegador navegue o cambie la ruta sin querer.\r\n  const handleFormSubmit = (ev) => {\r\n    ev.preventDefault();\r\n  };\r\n  // Pinto el campo de texto que busca el nombre del personaje. Como nos gusta cuidar la sem치ntica, este debe estar recubierto por una etiqueta <form />.\r\n  return (\r\n    <form onSubmit={handleFormSubmit}>\r\n      <label className=\"label\" htmlFor=\"name\">\r\n        Busca un personaje:\r\n      </label>\r\n      <input\r\n        className=\"input\"\r\n        type=\"text\"\r\n        id=\"name\"\r\n        value={props.nameFilter}\r\n        onChange={handleChange}\r\n      />\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default Filters;\r\n","import React from \"react\";\nimport \"../stylesheet/CharacterCard.scss\";\nimport { Link } from \"react-router-dom\";\nimport PropTypes from \"prop-types\";\n\n// 1. LISTADO DE PERSONAJES. Pinto el contenido dentro de cada tarjeta de personaje: cada una es un <li> que contiene una imagen, nombre y especie del personaje en cuesti칩n.\nconst CharacterCard = (props) => {\n  // console.log(props);\n  return (\n    <li className=\"card\">\n      <Link to={`/character-detail/${props.character.id}`}>\n        <img\n          className=\"card__img\"\n          src={props.character.image}\n          alt={`Imagen de ${props.character.name}`}\n        />\n        <h3 className=\"card__title\">{props.character.name}</h3>\n        <p className=\"card__description\">{props.character.species}</p>\n      </Link>\n    </li>\n  );\n};\n\nCharacterCard.propTypes = {\n  id: PropTypes.number,\n  image: PropTypes.string,\n  name: PropTypes.string,\n  specie: PropTypes.string,\n};\n\nexport default CharacterCard;\n","export default __webpack_public_path__ + \"static/media/no_results2.6ddd7d90.png\";","import React from \"react\";\nimport CharacterCard from \"./CharacterCard.js\";\nimport \"../stylesheet/CharacterList.scss\";\nimport image from \"../images/no_results2.png\";\nimport PropTypes from \"prop-types\";\n\nconst CharacterList = (props) => {\n  // console.log(props);\n  // Recibo por props los datos de App y pinto una lista que contendr치, mediante un mapeo, cada una de las tarjetas de los personajes como un item dentro de dicha lista.\n  const characterElements = props.characters.map((character) => {\n    return (\n      <CharacterCard\n        key={character.id}\n        character={character}\n        name={character.name}\n        species={character.species}\n        image={character.image}\n      />\n    );\n  });\n\n  // Si se busca un texto como XXX y no hay ning칰n personaje que coincida, se debe mostrar un mensaje del tipo \"No hay ningun personaje que coincida con la b칰squeda\".\n  if (props.characters.length === 0) {\n    return (\n      <div>\n        <p className=\"no-results\">No se encuentran resultados</p>\n        <img\n          className=\"no-results__img\"\n          src={image}\n          alt=\"No hay resultados\"\n          title=\"No hay resultados\"\n        />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"list-container\">\n      <ul className=\"card-list\">{characterElements}</ul>\n    </div>\n  );\n};\n\nCharacterList.propTypes = {\n  character: PropTypes.array,\n  id: PropTypes.number,\n  name: PropTypes.string,\n  image: PropTypes.string,\n  species: PropTypes.string,\n};\n\nexport default CharacterList;\n","import React from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport \"../stylesheet/CharacterDetail.scss\";\r\nimport PropTypes from \"prop-types\";\r\n\r\n// 4. DETALLE DE PERSONAJES. Nueva funcionalidad: al hacer clic sobre la tarjeta de un personaje, su informaci칩n aparecer치 a pantalla completa. Usaremos rutas y React router. En la pantalla de detalle aparecer치 adem치s de la foto, nombre y especie, el planeta de origen, el n칰mero de episodios en los que aparece y si est치 vivo o muerto.\r\n\r\nconst CharacterDetail = (props) => {\r\n  // console.log(props);\r\n  // 6. BONUS: Mejoras visuales. Mostrar si un personaje est치 muerto con un icono.\r\n  const checkStatus = () => {\r\n    if (props.status === \"Dead\") {\r\n      return \"游\";\r\n    }\r\n  };\r\n  // Renderizo en otra p치gina la tarjeta de detalle de un personaje una vez la usaria la selecciona. Para ello he utilizado React Router.\r\n  return (\r\n    <div className=\"detail\" key={props.id}>\r\n      <div className=\"detail__btncontainer\">\r\n        <Link to=\"/\">\r\n          <button className=\"detail__btn\">Volver</button>\r\n        </Link>\r\n      </div>\r\n      <div className=\"detail__imgcontainer\">\r\n        <img\r\n          className=\"detail__imgcontainer--img\"\r\n          src={props.image}\r\n          alt={props.name}\r\n          title={`Imagen de ${props.name}`}\r\n        />\r\n        <div className=\"detail__text\">\r\n          <h2 className=\"detail__name\">{props.name}</h2>\r\n          <ul className=\"detail__description\">\r\n            <li>Especie: {props.species}.</li>\r\n            <li>Planeta de origen: {props.origin}.</li>\r\n            <li>Aparece en: {props.episode} episodios.</li>\r\n            <li>\r\n              Estatus: {props.status}. {checkStatus()}\r\n            </li>\r\n          </ul>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nCharacterDetail.propTypes = {\r\n  id: PropTypes.number,\r\n  name: PropTypes.string,\r\n  image: PropTypes.string,\r\n  species: PropTypes.string,\r\n  status: PropTypes.string,\r\n  origin: PropTypes.string,\r\n  episode: PropTypes.number,\r\n};\r\n\r\nexport default CharacterDetail;\r\n","export default __webpack_public_path__ + \"static/media/404error.d97eab6a.jpeg\";","import React, { useEffect, useState } from \"react\";\nimport { Route, Switch } from \"react-router-dom\";\nimport \"../stylesheet/App.scss\";\nimport getDataFromApi from \"../services/getDataFromApi\";\nimport Header from \"./Header\";\nimport Filters from \"./Filters\";\nimport CharacterList from \"./CharacterList\";\nimport CharacterDetail from \"./CharacterDetail\";\nimport notFound from \"../images/404error.jpeg\";\nimport PropTypes from \"prop-types\";\n\nconst App = () => {\n  // usamos el hook useState para definir dos propiedades del estado del componente (cada uno de esos hooks act칰a sobre la propiedad especificada por medio de la funci칩n que le hemos pasado en cada caso, recibiendo como argumento inicial de useState un array y un string vac칤o.\n  const [characters, setCharacters] = useState([]);\n  const [nameFilter, setNameFilter] = useState(\"\");\n\n  // Recojo los datos del API haciendo uso del ciclo de vida de los componentes para evitar llamadas innecesarias a la misma.\n  useEffect(() => {\n    // llamo al servicio\n    getDataFromApi().then((data) => {\n      setCharacters(data); // cuando responde el servidor guardamos los datos en el estado\n    });\n  }, []); // con este array vac칤o, le decimos a React que solo ejecute este useEffect una vez\n\n  // Funci칩n manejadora del input que le paso por lifting a Filters.js para que la ejecute cuando sea necesario: \"Toma, hija, esta funci칩n, y ejec칰tamela cuando quieras\". Recibo por lifting el evento y la informaci칩n que la usuaria escribe en el campo de texto, la cual es utilizada para filtrar los nombres de los personajes que coincidan con dicho texto.\n  const handleFilter = (nameFilter) => {\n    setNameFilter(nameFilter);\n  };\n\n  // Filtro personajes independientemente de que la usuaria introduzca el texto en may칰sculas o min칰sculas.\n  const filteredCharacters = characters.filter((character) => {\n    return character.name.toLowerCase().includes(nameFilter.toLowerCase());\n  });\n\n  // Busco y pinto las tarjetas de los personajes que ha clicado la usuaria\n  const renderCharacterDetail = (props) => {\n    const userId = parseInt(props.match.params.characterId);\n    const clickedCharacter = characters.find((character) => {\n      return character.id === userId;\n    });\n\n    if (clickedCharacter) {\n      // console.log(clickedCharacter);\n      return (\n        <CharacterDetail\n          image={clickedCharacter.image}\n          name={clickedCharacter.name}\n          status={clickedCharacter.status}\n          species={clickedCharacter.species}\n          origin={clickedCharacter.origin}\n          episode={clickedCharacter.episode.length}\n        ></CharacterDetail>\n      );\n    } else {\n      // 7. BONUS: URL compatible. En el caso que la usuaria navegue a una URL inexistente, debemos mostrar un mensaje del tipo \"el personaje que buscas no existe\".\n      return (\n        <div className=\"notFound\">\n          <h2>El personaje que buscas no existe</h2>\n          <img className=\"not-found\" src={notFound} alt=\"not found\" />\n        </div>\n      );\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <Header />\n      <Switch>\n        <Route exact path=\"/\">\n          <Filters handleFilter={handleFilter} nameFilter={nameFilter} />\n          <CharacterList characters={filteredCharacters} />\n        </Route>\n        <Route\n          path=\"/character-detail/:characterId\"\n          render={renderCharacterDetail}\n        ></Route>\n      </Switch>\n    </div>\n  );\n};\n\nApp.propTypes = {\n  filteredCharacters: PropTypes.array,\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { HashRouter } from \"react-router-dom\";\nimport \"./stylesheet/index.scss\";\nimport App from \"./components/App\";\n\nReactDOM.render(\n  <HashRouter>\n    <App />\n  </HashRouter>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}